1.The functions that were the most challenging to define from the helper library was, getCharOption. This function was the hardest for me to implement in my code as I originally had the function built differently in milestone 1, and it seemed to work for the tests done in it. However, once I started on milestone 2, I noticed that it wasn’t working that way it should with Agent. So, I had to spend some time on the function, looking at ways I could rewrite it, while not affecting the results of the previous tests done. The main struggle for me was trying to figure out how to make the function read Agent, since I knew that it would be reading the first char which is ‘A’, it would not print out the error, since ‘A’ is a parameter for the function. I tried creating two chars, one to read the first char entered, and the second to read the next char entered, then if there was more than one char entered, the function would return the error statement. However, I found that didn’t work as I planned it to. I even tried debugging it, by printing out the values scanned into my char variables to see what was happening from my user input. Then I looked over to my getCString function to see if I could get any ideas and noticed that I could model the getCharOption off of that, which I did. I had the function count the length of the string entered, and if the length of the string was more than 1, then the error statement would print out. To make sure everything was working, I debugged it, by printing out the value of stringLen, and the string that was entered by the user, to make sure that everything was functioning properly. The way I made this function worked well, as it didn’t affect the results of the previous tests from milestone 1 and worked with the new chars that needed to be entered in milestone 2, while also creating an improved function.

2.The helper functions library has contributed towards making the code easier to read and maintain, since all the created functions are separated into a header file and a source file. This has made it easier to look through the code, as I did not have to skim through lines of code in the main c file to see what functions had to be created and I didn’t have to scroll back to different parts of the code to see what parameters had to be created, since they’re kept in separate files. With the functions being in separate files, I was able to split the tabs vertically for the commonHelper.c file and the a1ms2.c or a1ms1.c files. Making it very easy for me to sort through what I wrote in the code, while being able to make swift changes to parts of the code without it affecting the rest, since I was editing variables and other code stored inside the functions. 

3.Some of the advantages of being able to use structs, which the C programming language does provides its developers the ability to use, is that programmers can easily store several variables inside of a struct. This can help them easily sort out their variables inside the code, for example, in milestone 2 a construct was made and named after Account. This helped sort out which variables go where, as the variables needed for the account portion of the program, would be in the account struct. So, I didn’t have to name my variables after a certain part in the code, since I knew that they would be in the struct that is related to whatever part it is needed for, such as for the account struct, I could just name my integers number and type, instead of AccontNumber and AccountType. So, it helped me keep my variables well organized, while also knowing where each variable is stored and what it’s related to. There are some limitations such as not being able to use operators like “+” or “–“ inside the function, so I am unable to make something like a total variable and have it add num1 and num2 inside the struct, I would have to do it outside of the struct, and then add it to the total variable. However, I find that the advantages that structs provide for organization outweigh not be able to use operators.
